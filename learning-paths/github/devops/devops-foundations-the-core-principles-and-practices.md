

# DevOps foundations: The core principles and practices
https://learn.microsoft.com/en-us/training/paths/devops-foundations-core-principles-practices/



# 1 Discover DevOps

Optimize application lifecycle management through DevOps practices such as collaboration, continuous learning, agility, and automation. Your organization benefits from accelerated time to market, stability and reliability in operations, and minimize mean time to recovery



# 1.1 Introduction

DevOps is a concept that aims to address the challenges associated with traditional application lifecycle.

> "DevOps is the union of people, process, and products to enable continuous delivery of value to our end users." - Donovan Brown

Imagine that you work for a software development company in the retail industry. Your company is planning to migrate from an old app to a new app. However, the development team and the operations team have conflicting objectives. The development team wants to release new features quickly to attract more customers, while the operations team wants to ensure stability and reliability of the application. This conflict leads to delays in releasing new features and frequent downtime for the application. Your company realizes that it needs to adopt DevOps practices to overcome these challenges and deliver high-quality software efficiently and reliably.

![](https://learn.microsoft.com/en-us/training/wwl-azure/discover-devops/media/1-discover-devops.png)

In this module, learn about the key elements of DevOps culture and how they promote collaboration, transparency, shared responsibility, and continuous learning. The module covers topics such as collaboration, transparency, alignment, shared responsibility, accountability, empowerment, continuous learning, measurable outcomes, customer-centric focus, agility, automation, and security integration. Also, explore the value that DevOps brings to organizations, including accelerated time to market, adaptability to market dynamics, stability and reliability in operations, and minimizing mean time to recovery (MTTR). Additionally, understand how DevOps practices optimize application lifecycle management, impacting every phase from planning to operations.

By the end of this module, have a clear understanding of the principles, practices, and values of DevOps and how they can be applied to optimize software delivery and improve collaboration between development and operations teams.

# 1.2 What is DevOps?


https://youtu.be/kBV8gPVZNEE

DevOps is a commonly misunderstood and mischaracterized term. Before you explore more nuanced aspects of DevOps, it's essential that you understand its meaning and what DevOps isn't.

## What is DevOps (and what isn't)?

DevOps is a set of principles, practices, and values that are meant to enhance cross-team synergies, with the common goal of optimizing software delivery.

It's not a state that an organization can reach, but rather a continuous journey that requires an ongoing commitment and effort from all stakeholders.

It's also important to note that DevOps isn't tied to a specific technology or tools.

![](https://learn.microsoft.com/en-us/training/wwl-azure/discover-devops/media/2-devops-toolchain.png)

Now to explore DevOps in a contextual way, let's consider the traditional organization in the software development company example in which the development team and the operations team work in silos. Review challenges associated with this scenario and examine the meaning of DevOps in this context and how it can help.

## What challenges are associated with a traditional application lifecycle?

Traditional application lifecycle tends to separate developing software from the process of operationalizing it, which involves delivering it to its intended recipients and ensuring that it functions in the optimal manner. This siloed approach leads to many inefficiencies.

For one, developers and operational teams have commonly different objectives. The former focuses on innovation and continuous enhancements to their software. The primary objective of the latter is maintaining the stability and security of the environment they support.

The conflicting goals result in clashes, driving a wedge between different parts of the internal IT organization.

In addition, traditional operational practices are frequently based on an outdated, largely manual approach, which is inherently slow and vulnerable to human errors. This impedes the pace of innovation and increases the level of risk associated with deployment of new or updated versions of applications.

## How does DevOps help?

The purpose of DevOps is to address these inefficiencies. This is accomplished by uniting people, processes, and technologies. DevOps promotes coordination and collaboration between traditionally siloed roles, spanning such areas as development, operations, quality engineering, and security.


# 1.3 Explore DevOps culture

DevOps extends beyond technology, tools, and processes, forming an organizational culture. In the software-development company example, it becomes crucial to start by focusing on less tangible components of organizational life, such as team collaboration, shared responsibility, empowerment, continuous learning, and agile mindset. Here, use this context to examine DevOps culture and its key elements.

## What is DevOps culture?

DevOps culture encompasses the human and organizational factors that impact software development and delivery. As such, DevOps represents a culture that promotes collaboration, communication, and shared responsibility among all organizational stakeholders. The DevOps culture creates a collaborative, transparent, and continuously improving environment where teams work together to deliver high-quality software in an efficient and reliable manner. It involves a shift in mindset and behaviors, fostering a culture of trust, communication, and shared responsibility.

## What are the key elements of DevOps culture?

![](https://learn.microsoft.com/en-us/training/wwl-azure/discover-devops/media/3-devops-culture.png)

The key elements of DevOps culture can be summarized as follows:

* **Collaboration:** DevOps encourages teamwork and open communication across teams, eliminating silos and improving efficiency.

* **Transparency:** Openness and visibility into development and operations processes enhance understanding and decision-making.

* **Shared responsibility:** DevOps emphasizes collective efforts and continuous improvements, replacing blame with collaboration.

* **Continuous learning:** The DevOps culture promotes regular process reviews, identifying areas for improvement and enhancing efficiency.

* **Measurable outcomes:** DevOps relies on the use of metrics and key performance indicators (KPIs) to validate successful deliveries as well as to identify the need for innovations and enhancements. Measurable outcomes serve as an essential component of data-driven decision making and continuous learning.

* **Customer-centric focus:** DevOps values the customer's experience and emphasizes accelerated and reliable software delivery.

* **Agility:** DevOps organizations are adaptable and responsive to change, embracing an agile mindset.

* **Automation:** Automation increases efficiency, reduces errors, and accelerates development and deployment processes in DevOps.

* **Security Integration:** Security is an essential part of DevOps, permeating throughout each stage, which hints for the reason behind coining the term DevSecOps. DevSecOps is an extension of DevOps, with the focus on integrating security practices into the DevOps processes.



# 1.4 Explore DevOps goals and benefits

It should become fairly clear at this point that DevOps could bring significant value to practically any organization that relies on technology to deliver products and services to its customers. This certainly applies to the sample scenario we introduced in this module, where legacy operations negatively affected the pace of innovation and the risk associated with software deployment and maintenance. To appreciate the positive impact of DevOps, let's examine its benefits and goals in more detail.

## What are the primary goals and benefits of DevOps?

Embracing the DevOps culture can bring about a wide range of advantages for organizations, including:

* **Accelerating time to market**: Implementing DevOps practices facilitates the rapid release of software and its updates, reducing the time it takes to deliver them to their consumers. This acceleration enhances an organization's responsiveness to evolving customer needs and industry trends.

* **Adapting to market dynamics and competition**: DevOps fosters an agile and responsive development process, enabling organizations to quickly adapt to changes in the market and respond to competitive pressures. This adaptability ensures that businesses are able to adjust to evolving customer expectations.

* **Sustaining stability and reliability in operations**: DevOps principles emphasize collaboration between development and operations teams, leading to more stable and reliable operational environments. This collaboration helps identify and address issues early in the development cycle, minimizing disruptions and enhancing the overall stability of the operational environment.

* **Minimizing the mean time to recovery (MTTR)**: DevOps practices focus on automation, continuous monitoring, and rapid feedback loops, leading to quicker detection and resolution of issues. This, in turn, significantly improves the MTTR, ensuring that the impact of any disruption is minimized and that operations are quickly restored to their optimal state.

## Are DevOps benefits limited to traditional applications?

It's important to note that DevOps benefits extend beyond the lifecycle of traditional applications. Its scope includes, for example, such areas as machine learning (with operations applied to implementing machine learning models) and infrastructure (with Infrastructure as Code applied to deployment of underlying platform services).

*Machine Learning Operations*, often referred to as simply *MLOps*, focus on transitioning from the development of machine learning models to their provisioning in production environments. By following MLOps practices, organizations can ensure that their workloads are resilient and can be easily recreated. This includes monitoring, retraining, and redeploying models on an as-needed basis, and maintaining their stability following each deployment.

![](https://learn.microsoft.com/en-us/training/wwl-azure/discover-devops/media/4-machine-learning-operations.png)

*Infrastructure as Code*, commonly abbreviated as *IaC*, involves managing and provisioning compute, networking, and storage infrastructure via programming methods, rather than by relying on configuring physical hardware or using interactive administrative tools. IaC allows developers and operations teams to define and manage infrastructure elements such as servers, network devices, and databases using code. This code is typically written in a high-level, human-readable scripting language. The scripts are then executed to automate the provisioning and configuration of infrastructure, making it more efficient, consistent, and easily scalable.

![](https://learn.microsoft.com/en-us/training/wwl-azure/discover-devops/media/4-infrastructure-as-code.png)


# 1.5 Explore DevOps application lifecycle

While DevOps practices have a vast scope, their primary target is optimizing application lifecycle management. In the fictitious company example, migration from an existing app to a new app with updated features requires revisiting every phase of the application lifecycle. As such, learn how DevOps principles can significantly alter how each phase is implemented, from planning, through development and delivery, to operations. In this unit, step through a high-level overview of these implementations.

## Application Lifecycle phases

Application lifecycle phases include planning, development, delivery, and operations.

*Screenshot of the DevOps and Application Lifecycle.*

![](https://learn.microsoft.com/en-us/training/wwl-azure/discover-devops/media/5-devops-lifecycle.png)

### Planning

The planning phase involves reviewing customer needs in order to outline and define features and capabilities of the software to be developed. Such software can range from individual microservices to portfolios consisting of multiple products. The outcome defines software requirements, scope, and milestones for the application's development and deployment. From the DevOps perspective, the primary considerations during this phase include agility, customer-centric focus, alignment, and visibility.

### Development

The development phase covers all aspects of developing application code. These aspects include programming, testing, and code reviews. To comply with DevOps practices, the code should reside in a source control system, which facilitates collaboration and supports versioning. A working version of the code is used to build artifacts suitable for subsequent delivery. Such artifacts can take the form of executable binaries, software libraries, container images, installer packages, configuration files, deployment scripts, or even documentation.

Changes at this phase should be applied in small increments through automated testing and build, referred to as continuous integration (CI), which accelerates the development process and enhances agility.

### Delivery

Delivery is the process of deploying the artifacts built during the development stage into production environments in a consistent and reliable manner. While the ultimate goal at this phase is full automation through continuous delivery (CD), some organizations, especially in early stages of their DevOps adoption, might choose to implement manual approvals or checks. As the confidence in DevOps practices grows, it's typically possible to fully automate these checks. For example, a successful, unattended verification of a deployment to a staging environment might serve as the basis for transitioning to the production environment. Automation helps make delivery processes scalable, repeatable, and, more resilient (by minimizing the possibility of human error). The key to a successful implementation of such an approach is following DevOps practices, including proper testing, the use of observable measurements, and continuous learning.

Delivery should also take into account provisioning and configuring the target environment's infrastructure through IaC. Treating infrastructure as code offers a range of benefits, including consistency, reproducibility, and agility.

### Operations

The operations phase involves maintaining, monitoring, and troubleshooting applications in production environments. From the DevOps perspective, the primary objectives at this stage are stability and reliability, rapid incident response, security and compliance, and customer satisfaction. To some extent, reaching these objectives is dependent on having properly implemented measurable outcomes. DevOps processes also rely on so called feedback loops that deliver data reflecting the current state of the deployed application such as performance metrics, responsiveness, and overall user experience, including improved or degraded functionality.

During this phase, it's important to ensure the maximum levels of collaboration between development, operations, and security teams. This phase also serves as the essential source of continuous learning.

## What's the final stage of the application lifecycle?

As the name indicates and the image at the beginning of this unit illustrates, the application lifecycle is, by design, a circular process. There's a deterministic beginning and end of an application lifespan determined by its inception and decommissioning events. However, following the initial deployment (or frequently, even earlier), feedback from users and monitoring data inform subsequent updates and the evolution of the application.

> **Note**
>
> Keep in mind that even though security was mentioned only a few times throughout this unit, according to DevSecOps principles, its role pervades throughout application lifecycle. Effectively, security-related considerations should be accounted for during each phase, starting at the very beginning of the initial planning.


# 1.6 Module assessment

Choose the best response for each question.

*AI-generated content The question and answer choices in this module assessment were created with AI.*

**Provide feedback**

## 1.
**How does the DevOps principle of 'shared responsibility' help mitigate conflicts between development and operations teams?**

- It allows the operations team to focus solely on stability while development manages new features.
- **It ensures that both teams are accountable for both feature delivery and operational stability.** ✓
- It provides development teams with full control over deployment processes.

## 2.
**How does adopting an agile mindset in a DevOps culture help resolve team conflicts?**

- **It promotes adaptability and responsiveness to change, which aligns team efforts towards common goals.** ✓
- It allows development teams to ignore operational feedback and focus on rapid coding.
- It ensures that all decisions are made by a central authority to maintain consistency.

## 3.
**Which example demonstrates a DevOps principle being applied to resolve a conflict between development and operations teams?**

- Operations teams are responsible for all testing and deployment processes, while development focuses solely on coding.
- Development teams independently decide release schedules, and operations teams handle post-release issues.
- **Both development and operations teams collaborate on creating automated deployment pipelines and share responsibility for post-release stability.** ✓

## 4.
**What is the main goal of continuous delivery (CD) in the DevOps lifecycle?**

- To automate the provisioning of infrastructure
- To maintain, monitor, and troubleshoot applications
- **To deploy artifacts into production environments consistently and reliably** ✓

## 5.
**How does DevOps culture facilitate continuous improvement in an organization?**

- By enforcing strict hierarchical decision-making processes
- **By fostering an environment of shared knowledge and iterative feedback loops** ✓
- By minimizing team interactions to focus on individual productivity

## 6.
**A company implementing DevOps practices has reported accelerated time to market and increased system reliability. Which DevOps principle is most likely contributing to these improvements?**

- Manual testing procedures
- **Automation of development processes** ✓
- Siloed team structures

## 7.
**Your company wants to foster a culture of trust, communication, and shared responsibility among teams. Which DevOps cultural element should be emphasized?**

- **Transparency** ✓
- Security integration
- Automation

## 8.
**A tech company has adopted a DevOps approach and experienced a reduction in system downtime. Which DevOps practice most directly influences this outcome?**

- Monthly manual audits
- **Integrated security practices (DevSecOps)** ✓
- Isolated development environments

## 9.
**Which DevOps principle focuses on ensuring that infrastructure can be easily recreated and is resilient?**

- **Infrastructure as Code (IaC)** ✓
- Continuous integration (CI)
- Continuous delivery (CD)



# 1.7 Summary

In this module, you have learned about DevOps and its role in addressing the challenges associated with traditional application lifecycles. DevOps brings together people, processes, and technologies to promote coordination and collaboration between different roles, optimizing software delivery. It's a continuous journey that requires ongoing commitment and effort from all stakeholders. DevOps culture goes beyond technology and processes and encompasses collaboration, transparency, shared responsibility, continuous learning, and customer-centric focus. It brings significant value to organizations by accelerating time to market, enabling agility and responsiveness, promoting stability and reliability, and minimizing mean time to recovery. DevOps practices optimize application lifecycle management, impacting every phase from planning to operations.

The main takeaways from this module are:

* DevOps is a concept that aims to address the challenges associated with traditional application lifecycle by bringing together people, processes, and technologies to optimize software delivery.

* DevOps culture promotes collaboration, transparency, shared responsibility, continuous learning, and customer-centric focus, creating a collaborative and continuously improving environment.

* DevOps brings significant value to organizations by accelerating time to market, enabling agility and responsiveness, promoting stability and reliability, and minimizing mean time to recovery.

* DevOps practices optimize application lifecycle management, impacting every phase from planning to operations, with security considerations accounted for throughout each phase.




# 2 Plan with DevOps

Plan your software development projects agilely using GitHub Projects boards. You'll facilitate collaboration, shared responsibility, continuous learning, and optimization through version control, continuous integration and continuous testing, and Infrastructure as Code.


# 2.1 Introduction

DevOps influences the entire application lifecycle starting with the planning phase.

Imagine that you work for a software development company in the retail industry. Your company is planning to migrate an online store from an old app to a new app to stay competitive in the market. The development and operations teams are working in silos, with little collaboration and communication, and lack of accountability, which has made planning your project more difficult. To address these issues, your organization decides to adopt a DevOps approach to build mutual respect among teams, set clearly defined roles and responsibilities, become agile, and implement practices that improve collaboration and communication.

In this module, learn how to foster a DevOps culture in an organization by promoting collaboration, transparency, shared responsibility, and continuous learning. You'll learn about the importance of an Agile approach to software development and project management as part of DevOps, the characteristics of different agile frameworks, fundamental DevOps practices such as version control, continuous integration, continuous testing, continuous delivery, continuous monitoring, continuous security, and Infrastructure as Code, and how GitHub Projects can facilitate the planning of your projects.

By the end of this module, you'll have a clear understanding of the principles, practices, and values of DevOps and how they can be applied to optimize application lifecycle management in every phase from planning to operations.


# 2.2 Foster DevOps culture


In order to fully realize DevOps benefits, organizations need to make a conscious effort of fostering the DevOps culture among their teams. This involves promoting collaboration, automation, and a mindset of continuous improvement, which ultimately will lead to faster, more reliable, and customer-centric software delivery. Such effort would be essential in our sample scenario, where the organization just started exploring the option to adopt DevOps practices. However, changing a corporate culture is a challenging undertaking. In this unit, you'll review a set of recommendations that should facilitate addressing this challenge.

## How should organizations foster DevOps culture?

![](https://learn.microsoft.com/en-us/training/wwl-azure/plan-with-devops/media/2-foster-devops-culture.png)

Given the core DevOps culture elements, there are many actions that organizations can take to develop and foster their internal DevOps culture:

* **Build mutual respect within and between its teams**: Teams should operate by using a code of ethics based on mutual respect and blameless culture. Teams should take collaborative ownership of any issues encountered during software delivery and identify improvement opportunities rather than looking for a culprit.

* **Clearly define roles and responsibilities of each individual team**: Team decision-making should be democratic, but structured to ensure that decisions are made efficiently. When there are differing opinions about a situation, someone must be responsible for making the final decision based on the evidence that's presented.

* **Facilitate continuous learning and improvement**: Organizations should establish architecture review boards and centers of excellence to develop and maintain their best practices in the areas of development, operations, and security. Team structure should ensure that everyone is a specialist in their function and a generalist in all other functions so that team members can support each other when needed.

* **Commit to optimization**: Business and customer-driven needs should be the primary factors that determine the overall DevOps strategy. The teams need to regularly review their standard operating procedures, apply creative thinking, and seek areas of improvement.

* **Embrace safe experimentation**: Organizations should develop means for testing and evaluating new functionality in isolation from the production environment and delivering innovative solutions in compliance with safe deployment practices.

Exemplifying these recommendations, Microsoft has a well-established live site culture that is based on the principles of DevOps. The company has a strong focus on customer satisfaction and operational excellence, and it has a culture of continuous learning and improvement. Key aspects of Microsoft's live site culture:

* Learn once and share.
* Drive with data.
* Automate everything.
* Use telemetry to drive decisions.
* Embrace failure.
* Root cause is key.
* Lock down the environment.
* Monitor everything.
* Plan for scale.
* Live site first.
* Detect before customers.
* Configuration as code.


# 2.3 What is Agile?


We used the term agile in the previous module to describe one of the essential elements of DevOps culture, representing the ability to rapidly respond to customer feedback and needs. This term also appeared several times in the unit describing the correlation between DevOps and the application lifecycle. However, there's also another, more specific meaning of Agile (in the capitalized format), which describes an approach to software development and project management. Such an approach is commonly associated with DevOps practices. In our sample scenario, transitioning from the traditional Waterfall approach to Agile would help the organization realize a range of DevOps benefits. In this unit, explore the primary characteristics of Agile and examine its correlation with DevOps.

![](https://learn.microsoft.com/en-us/training/wwl-azure/plan-with-devops/media/3-agile-methods.png)


## Agile principles and values

Agile is an approach to software development that promotes team collaboration, continuous improvement, and automation, with the ultimate goal of faster, more reliable, and customer-centric software delivery. The term originated from the Agile Manifesto, created in 2001 by a group of software developers, providing a set of guiding principles for modern software development. The manifesto included four foundational statements that prioritized individuals and interactions, working solutions, and customer collaboration over rigid processes and tools. In particular, these statements assigned more value to:

- Individuals and interactions over processes and tools.
- Working software over comprehensive documentation.
- Customer collaboration over contract negotiation.
- Responding to change over following a plan.

## Agile methods and practices

The Agile Manifesto and Agile principles provide a set of values and guidelines, but they're intentionally not prescriptive in terms of specific methods and practices. Instead, Agile is meant to be flexible and easily adaptable, allowing organizations and teams to choose a more detailed approach according to their preferences and needs.

These detailed, comprehensive approaches are commonly referred to as frameworks. Their purpose is to cover all phases of the DevOps lifecycle, including planning, development, delivery, and operations. Some of the more popular Agile frameworks include Scrum and Kanban.

## What is Scrum?

Scrum is a framework used by teams to manage work and solve problems collaboratively in short (typically between one and four weeks long) iterations called sprints. To facilitate collaboration and progress, sprints are structured based on events, artifacts, and roles.

- **Events**, commonly referred to as ceremonies, include meetings taking place daily (Daily Scrum, typically limited to 15 minutes, also known as daily standup) and at the beginning and end of each sprint (Sprint Planning, Sprint Review, and Sprint Retrospective).
- **Artifacts** define a prioritized list of features, enhancements, and fixes to develop. Such artifacts might cover the span of a project or a sprint (Product Backlog or Sprint Backlog, respectively), or they might aid Daily Scrum meetings (task boards and sprint burndown charts). A task board provides a visual way to track the progress of each backlog item. It displays backlog items divided into the tasks required to complete it. Tasks are placed in separate columns (labeled To do, In progress, and Done) based on their status. The sprint burndown chart serves as a visual indicator of whether the team is on track to complete its assigned work by the end of the sprint. It consists of a graph that displays the daily total of remaining work, typically shown in hours.
- **Roles** include the product owner, Scrum master, and Scrum team, each with its clearly defined responsibilities. The product owner represents the project stakeholders and is responsible for defining, maintaining, and prioritizing the product backlog. The Scrum master oversees the Scrum process, looking for areas for improvements, resolving any blocking issues, and ensuring that the Scrum principles are followed. The Scrum team is responsible for building the product, with the ownership of its engineering and quality components.

![](https://learn.microsoft.com/en-us/training/wwl-azure/plan-with-devops/media/3-agile-scrum-lifecycle-diagram.png)


In the Sprint Planning event, the team chooses backlog items to work on during the upcoming sprint. The selection is made based on priority and an estimated amount of work required to complete an item. The metric called velocity is used to measure the amount of work a team can complete in a given sprint. Once the sprint execution starts, the team decides how to work on the Sprint Backlog items. During Sprint review, the team demonstrates their accomplishments to stakeholders. Sprint retrospective is part of continuous learning. It serves as the opportunity to review the most recently completed sprint, identify areas for improvement, and help determine the list of actions for the next sprint.

## What is Kanban?

![](https://learn.microsoft.com/en-us/training/wwl-azure/plan-with-devops/media/3-what-is-kanban.png)

Kanban is the Japanese word for a signboard or billboard. In the context of Agile, the concept of Kanban has been conceived as a means for improving the efficiency of manufacturing processes, but, in recent years, it became prevalent in software development projects.

The key principle of this approach is visualization of project-related work in the form of Kanban boards. These can be physical boards or software applications that display cards arranged into columns representing the status of individual project items. Commonly used column names include To-do, Doing, and Done, although teams can customize them to accurately reflect all relevant stages in a project delivery workflow (such as development and testing). Visualizing work as cards in different states on a board simplifies the assessment of project status and identifying potential productivity issues.

![](https://learn.microsoft.com/en-us/training/wwl-azure/plan-with-devops/media/3-agile-kanban-board-sample.png)


These cards correspond to product backlog items in the Scrum framework. The cards can be customized to include references to other items in the product delivery process, such as tasks and test cases.

While the concept of a backlog is common in Kanban and Scrum, it's important to note that Kanban is more flexible and doesn't involve iterations. Work items can be added, reprioritized, or removed from the backlog based on the team's capacity and the changing needs of the project or service being managed with Kanban.

![](https://learn.microsoft.com/en-us/training/wwl-azure/plan-with-devops/media/3-kanban-pull-model.png)

In particular, Kanban promotes the use of a pull model, in which stakeholders add requests to the backlog list of tasks, items, or work that needs to be completed. The development team selects items from the backlog and adds them into the active work process depending on their priority and the team's resources availability. This minimizes the quality issues associated with the pull model, in which stakeholders arbitrarily assign work to development teams, frequently with unrealistic deadlines. In addition, to optimize productivity, Kanban supports imposing limits on the number of items that the development team is currently working on, referred to as work in progress or simply WIP.

Kanban framework also relies on lead time and cycle time metrics to measure effectiveness and throughput of its workflow. Lead time is the total time it takes for a work item to transition from its inception until its delivery to the customer. Cycle time represents the duration of the actual work on an item once it has been pulled into the active work state.

Another commonly used component of Kanban is a cumulative flow diagram (CFD). It's a chart that illustrates the number of items in each state over time, typically across several weeks. It resembles a stacked time series chart, with the horizontal axis representing the timeline and the vertical axis representing the cumulative number of work items. Each state is displayed as a differently colored area, facilitating identifying trends in backlog item processing. An increase in size of one or more colored areas typically indicates an issue in the workflow, such as a bottleneck or inefficiency.

![](https://learn.microsoft.com/en-us/training/wwl-azure/plan-with-devops/media/3-agile-kanban-cumulative-flow-diagram.png)

## What are the differences between Scrum and Kanban?

Both Scrum and Kanban are considered to be Agile frameworks with the common goal of improving the efficiency and effectiveness of software development. However, each of them offers a different approach to reaching this goal, including their respective principles and practices. In particular:

- **Work cadence**: Scrum uses fixed-length sprints, while Kanban operates based on a continuous flow model, with work being pulled by development teams according to the availability of their resources.
- **Roles and ceremonies**: Scrum has clearly defined roles and ceremonies, while Kanban doesn't prescribe any, instead allowing teams to adapt these according to their specific needs.
- **Work planning**: Scrum uses a prioritized backlog with work committed to during sprint planning. Kanban uses a dynamic backlog, with no commitments for a specific period. In addition, Kanban supports the concept of WIP limits.
- **Adaptability to change**: Scrum discourages changes to committed work during the sprint. Kanban facilitates adaptation to changes at any point.
- **Visualizations**: Scrum uses sprint boards and burndown charts. Kanban relies on Kanban boards.
- **Metrics**: Scrum uses sprint-related metrics such as velocity and burndown charts. Kanban emphasizes such metrics as lead time and cycle time.


# 2.4 Explore DevOps practices

Incorporating DevOps into the application lifecycle involves implementing a range of DevOps practices. The ability to maximize DevOps benefits is highly dependent on the extent to which this implementation is successful. In our sample scenario, the organization would need to introduce significant changes to its operating model, starting with promoting collaboration and communication between development and operations teams as well as investing in version control, automation, continuous integration, continuous testing, continuous delivery, and continuous monitoring. You'll explore these practices in this unit.

![](https://learn.microsoft.com/en-us/training/wwl-azure/plan-with-devops/media/4-devops-practices.png)

## Version control

Version control is the practice of managing updates to code by storing it in designated repositories, tracking its revisions, and maintaining change history. This facilitates code reviews and the ability to recover from programming errors. In addition, version control systems (VCS) such as Git allow for collaboration in code authoring among multiple developers through such features as repository cloning, pull requests, code change merges, conflict resolution, and support for rollbacks. The use of version control is a fundamental DevOps practice. Version control is also a prerequisite for such practices as continuous integration and infrastructure as code.

## Continuous Integration (CI) and Continuous Testing

One of the core practices of DevOps is automation. In this case, automation applies to the process of merging code changes, testing them, and building resulting artifacts, as early in the application lifecycle as possible. The intention is to detect any potential issues in the development phase, since this minimizes the effort and cost involved in fixing them. Automated tests validate that code changes haven't introduced errors or regression issues.

## Continuous Delivery (CD)

Continuous delivery automates the process of deploying artifacts built as part of CI, making them available to their consumers. CD automates progression of these artifacts through different environments, such as testing, staging, and production. Continuous integration and continuous delivery (CI/CD) together form a unified, streamlined, end-to-end software development and delivery process.

## Continuous monitoring

Continuous monitoring provides automated real-time visibility into the health and performance of the entire application stack, including its underlying infrastructure. This is accomplished through the collection of telemetry, including logs and metrics, and customizable alerting that delivers notifications about anomalous behavior, facilitating prompt remediation actions.

## Continuous Security (DevSecOps)

Security is an essential part of every phase of the DevOps-based application lifecycle, which is the reason for coining the term DevSecOps. DevSecOps is an extension of DevOps, with the focus on integrating security practices into each stage—from planning, through coding, testing, and deployment, to operations.

## Infrastructure as Code (IaC)

Infrastructure as Code is an integral component of modern software development and operations practices. It involves the use of programming methods to provision and manage infrastructure services. IaC defines infrastructure components such as servers, network devices, and databases by using code. Such code typically resides in a VCS, which manages and tracks changes to infrastructure configurations. The use of code facilitates automated provisioning and configuration of infrastructure, enhancing efficiency, consistency, and scalability. In addition, IaC can be (and frequently is) integrated with CI/CD, yielding a comprehensive software delivery strategy by combining infrastructure provisioning, with application build, test, and deployment into one continuous, fully automated sequence.


# 2.5 Plan with GitHub

Both GitHub and Azure DevOps support a range of DevOps planning capabilities. Considering that the organization in the sample scenario plans to rely on GitHub for its DevOps transition, with focus on the former. In particular, explore GitHub Projects and Project Boards, available to all GitHub customers.

## What are GitHub Projects?

GitHub Projects is a feature hosted by the GitHub platform providing the ability to organize, track and manage work in a collaborative and visual manner. This feature is suitable for managing software development lifecycle, although it can be used in practically any scenario that involves project-related work. It closely integrates with other GitHub components such as repositories, issues, and pull requests. It provides a way to plan, track progress, and coordinate tasks within a repository and across repositories.

![](https://learn.microsoft.com/en-us/training/wwl-azure/plan-with-devops/media/5-github-projects.png)

Each project is automatically accessible in the table, board, and roadmap layout. You also have the option of creating views by filtering, grouping, and sorting components included in the project, generating configurable charts, and adding custom fields based on your individual preferences or needs.

GitHub Projects support milestones, which represent target dates of specific goals or deliverables. Milestones implement a timeline for the project and allow teams to track their progress.

Projects include built-in workflows that you can use to update the status of items based on predefined events, such as automatically setting the status of a newly created issue to Todo or automatically setting the status to Done when the issue is closed. By default, two workflows are enabled in a newly created project:

- When issues or pull requests in your project are closed, their status is set to Done
- When pull requests in your project are merged, their status is set to Done.

## What is a GitHub Projects board?

A GitHub Projects board offers a visual representation of the corresponding project. It's accessible via the board layout and supports a Kanban experience. It consists of columns and cards that allow you to organize and track issues and pull requests. Columns can be customized to represent different project stages. Cards represent work items, such as issues, draft issues, or pull requests. You can drag cards between columns to reflect their current status or stage of completion and the value of those items adjust to match the column you drag them to. Each card can contain many fields including labels, assignees, due dates, and descriptions. These fields allow you to specify additional information about the work being tracked.

![](https://learn.microsoft.com/en-us/training/wwl-azure/plan-with-devops/media/5-github-projects-board.png)

By using the views functionality, you have the option to create multiple boards within a repository, each with its own, distinct set of columns. You can also set a limit for the number of cards in a particular column in a board layout to implement a WIP limit.

## How to start with GitHub Projects boards?

Before you start a new GitHub project, create a repository. A repository stores all of your project's files and provides a platform for managing your work and collaborating with others. To track project-related work items, use issues. Issues provide a convenient method for communicating and making decisions within a team, including discussions on application lifecycle details, such as bugs or performance reports, project planning, or brainstorming a new idea. To provide suggestions for improvements, use pull requests containing proposed changes.

In addition, consider using the default labels included in every repository or creating custom ones. Labels help with keeping track of project goals, designating bugs, differentiating between various types of work, and indicating the status of issues or pull requests. For example, you can locate all bugs in your project by filtering for issues with the corresponding label.

https://youtu.be/qT0VMdx7vuI

When creating a project, you can either start from scratch or use many project templates with predefined board structures targeting the most common use cases, including, for example, Team planning, Feature release, Kanban, Iterative development, or Bug tracker.



# 2.6 Agile plan and management using GitHub

## Scenario

Remember this module's scenario in which you're working for a software development company in the retail industry that is planning to migrate its online store to a new app but is experiencing difficulties planning the project due to little collaboration and communication between the development and operations teams. Since you have decided to use GitHub for Agile planning and management, this lab gives you the opportunity to create a GitHub repo, associated milestones and issues, a project, and project board. Additionally, you'll be able to add a draft item to the project board and an item based on an issue and review the automation settings.

## Objectives

In this lab, you will:

* Create a GitHub repo, project, and project board
* Create and manage project board items

## Requirements

* This lab requires **Microsoft Edge** or an Azure DevOps-supported browser.
* **Set up an GitHub account:** If you don't already have a GitHub account that you can use for this lab, create one by following the instructions available in the article Creating an account on GitHub.

## Exercises

During this lab, you'll complete the following exercises:

* Exercise 1: Create a GitHub repo, project, and project board
* Exercise 2: Create and manage project board items

https://microsoftlearning.github.io/AZ-2008_DevOps_Foundations_Core_Principles_Practices/Instructions/Labs/01-agile-planning-management-using-github.html


# 2.7 Module assessment


Choose the best response for each question.

*AI-generated content The question and answer choices in this module assessment were created with AI.*

**Provide feedback**

## 1.
**Your team is planning the next sprint using GitHub Projects. How can you ensure that tasks are prioritized effectively on the project board?**

✅ **Use labels and milestones to indicate priority and deadlines for tasks**

- Create multiple project boards for different team members
- Assign all tasks to a single team member for oversight

## 2.
**Your DevOps team wants to implement a framework that emphasizes work visualization and limits the number of tasks being handled at once. Which framework should they choose?**

- Scrum
- ✅ **Kanban**
- Extreme Programming (XP)

## 3.
**Suppose your organization is using GitHub Projects to manage a software development task. How can you automatically update the status of an issue to 'Done' when it is closed?**

- Manually change the status of each issue to 'Done' after closing.
- ✅ **Enable the built-in workflow that sets the status to 'Done' when issues are closed.**
- Use a pull request to change the status to 'Done'.

## 4.
**In GitHub Projects, what is the purpose of using labels on issues and pull requests?**

- To initiate automated testing processes
- ✅ **To categorize and track project goals, bugs, and status of work items**
- To assign tasks to team members automatically

## 5.
**A company wants to improve its software delivery process by adopting DevOps practices, including version control and CI/CD. What is the primary benefit of implementing CI/CD in this context?**

- ✅ **It automates the testing and deployment of code changes, reducing manual intervention.**
- It provides a platform for developers to collaboratively author code.
- It tracks changes to code, allowing rollbacks when necessary.

## 6.
**An organization wants to implement DevOps practices to improve its software delivery process. Which DevOps practice should be prioritized to ensure that code changes are tested before deployment?**

- ✅ **Continuous Integration**
- Continuous Monitoring
- Version Control

## 7.
**In a DevOps environment focusing on customer-centric software delivery, which Agile framework prioritizes continuous improvement and collaboration over rigid processes and tools?**

- ✅ **Agile Manifesto**
- Lean
- Scrum

## 8.
**What impact does version control have on the agility of a development team in a DevOps environment?**

- It limits agility by enforcing strict coding standards and review processes.
- ✅ **It enhances agility by allowing simultaneous work on multiple features without conflicts.**
- It reduces agility by requiring all changes to be manually merged.

## 9.
**Which of the following Agile frameworks emphasizes a continuous flow model and allows for work items to be added or reprioritized based on team capacity and changing needs?**

- ✅ **Kanban**
- Scrum
- Waterfall

---

## Answer Explanations:

**1.** Labels and milestones help organize and prioritize tasks effectively on project boards.

**2.** Kanban emphasizes visualization and WIP (Work In Progress) limits.

**3.** GitHub Projects has built-in workflows for automatic status updates.

**4.** Labels serve as categorization and tracking tools for different types of work.

**5.** CI/CD's primary benefit is automation of testing and deployment processes.

**6.** Continuous Integration ensures code is tested before deployment through automated builds and tests.

**7.** The Agile Manifesto emphasizes individuals and interactions over processes and tools.

**8.** Version control enables parallel development and conflict resolution, enhancing agility.

**9.** Kanban operates on continuous flow without fixed iterations, allowing flexible prioritization.



# 2.8 Summary


In this module, you learned about fostering a DevOps culture by building mutual respect among teams, defining roles and responsibilities, facilitating continuous learning and improvement, committing to optimization based on business and customer needs, and embracing safe experimentation.

By promoting collaboration, automation, and a mindset of continuous improvement, organizations can achieve faster, more reliable, and customer-centric software delivery.

The module also covered Agile methodologies such as Scrum and Kanban, which provide frameworks for managing work and solving problems in iterative cycles. Scrum uses fixed-length sprints and defined roles and ceremonies, while Kanban operates on a continuous flow model and allows teams to adapt their own processes.

The main takeaways from this module are that fostering a DevOps culture requires a focus on collaboration, automation, and continuous improvement. By implementing Agile methodologies like Scrum and Kanban, organizations can effectively manage work and solve problems in iterative cycles. Additionally, incorporating DevOps practices such as version control, continuous integration and testing, continuous delivery, continuous monitoring, continuous security, and infrastructure as code can streamline the software development and delivery process.


# 3 Develop with DevOps

Streamline updates to your software development projects by applying version control with Git and GitHub. Your software lifecycle improves through the implementation of continuous integration, shift-left testing, and shift-left security.


# 3.1 Introduction

Version control and source control are essential practices in DevOps, particularly in the development phase, enabling continuous integration and infrastructure as code.

Imagine that you work for a software development company in the retail industry that is planning to migrate an online store from an old app to a new app. The application is called eShopOnWeb with the necessary layered application architecture. However, the development team and the operations team have different processes for managing the development of the new app and this conflict leads to delays in releasing new features and increases the risk of errors in production. Your company decides to implement a DevOps approach, including the use of Git and GitHub, to facilitate software lifecycle management.

![](https://learn.microsoft.com/en-us/training/wwl-azure/develop-with-devops/media/1-develop-with-devops.png)


In this module, learn about the principles and benefits of version and source control, the differences between centralized and distributed version control systems, Git terminology and features for tracking changes, reviewing history, creating branches, merging branches, collaborating with multiple developers, and automating processes like continuous integration and deployment. Additionally, you'll also explore GitHub for hosting Git repositories and streamlining updates to project repositories, and the importance of integrating shift-left testing and shift-left security in the software lifecycle.

By the end of this module, you'll have a clear understanding of version control and source control principles, the usage of Git and GitHub for managing software development projects, the importance of continuous integration, and the shift-left approach for testing and security in DevOps.


# 3.2 Explore source control and version control

The use of source and version control is a fundamental DevOps practice. It's also a prerequisite for such practices as continuous integration and infrastructure as code, both of which are crucial to reaching the full DevOps potential. The organization in our sample scenario should review its current collaborative software development strategy and transition to a distributed version control model such as Git, especially considering its plans to use GitHub for its software lifecycle management. This, however, requires sound understanding of the version and source control principles and their benefits, which we'll cover here.

## Source control and version control

![](https://learn.microsoft.com/en-us/training/wwl-azure/develop-with-devops/media/2-source-control.png)

The terms *source control* and *version control* are often used interchangeably, and in many contexts, they refer to the same concept. In general, both of them are associated with the practice of managing changes to code in a shared development environment. However, you might encounter more nuanced scenarios in which their meaning is slightly different. In these scenarios, *source control* designates a system that manages changes to source code files while *version control* includes change management of any file type for purposes that extend beyond source code alone. Going forward, for the sake of consistency, we'll be using the term *version control* to represent Git-based collaborative software repositories available in GitHub and Azure DevOps.

## What are the benefits of version control?

Version control keeps track of changes to files within its scope of management. This offers a wide range of benefits:

* **History and version tracking**: You have the ability to review history of changes to any file, including the ability to determine when each individual change took place and what was their scope. This also provides traceability, typically by associating each set of changes with a unique identifier.

* **Rollback and recovery**: If there's an error or an issue, you can easily revert changes to recover the known, working version of the affected file.

* **Branching and merging**: If you need to extend the functionality of the current code by adding another feature or fix a newly discovered bug, you can create a so-called branch, which allows you to work independently against the existing codebase. The new branch is initially identical to the *main* branch hosting the current code. Once you completed your changes, you merge the new branch with the main branch. While this might still lead to conflicts (if another developer decided to modify the same set of files in the meantime via another branch), their scope is limited and they can typically be easily identified and resolved.

![](https://learn.microsoft.com/en-us/training/wwl-azure/develop-with-devops/media/2-branch-strategy.png)

* **Collaboration and parallel development**: Conflict resolution provisions supplemented by branching and merging facilitate having multiple developers working on the same codebase, which increases efficiency. With distributed control systems, such as Git, it's even possible to author code in a disconnected mode. Collaboration also involves mutual peer reviews of pull requests, promoting knowledge sharing and transparency.

* **Automation**: Version control is an essential part of continuous integration and automated deployments. Automated build and testing can be triggered automatically whenever a new version of the code is pushed to the version control repository or merged with the main branch. Different versions of the code can be deployed into different environments.

# 3.3 Explore version control using Git

There are different types of version control systems (VCS), but generally they can be categorized as centralized and distributed. In recent years (partially due to the growing popularity of DevOps), the latter category gained significant popularity, with Git becoming the de facto standard in modern software development. This particular VCS would be the most suitable choice for the organization in our sample scenario, especially considering its intention to use GitHub as the target platform for its DevOps transition. In this unit, explore the use of Git as version control.

![](https://learn.microsoft.com/en-us/training/wwl-azure/develop-with-devops/media/3-distributed-centralized.png)

## Centralized vs. Distributed Version Control

Both centralized version control systems (CVCS) and distributed version control systems (DVCS) offer the ability to manage and track changes in software development projects. The primary differences between them are related to the way they implement repositories and collaboration. In particular:

**Repository location**: In centralized systems, there's a single, centralized instance of the repository containing the full history of the project. In distributed systems, each team member would typically have one, fully functional local copy of the entire repository, potentially including its full version history.

**Network connectivity**: In centralized systems, access to the centralized instance of the repository is required to perform many actions, including updates and history retrieval. In distributed systems, all activities can be performed against the local copy of the repository.

**Collaborative model**: In centralized systems, developers check out files from the centralized instance of the repository while connected to it over a network before making modifications and committing the changes. This prevents changes to be checked out files by others. In distributed systems, developers make and commit changes to their local copy of the repository, which, at some point later, are synchronized with other copies.

**Branching and merging model**: In centralized systems, branching and merging typically requires coordination with others. In distributed systems, branches can be created independently in local copies and merged afterwards.

It's worth noting that, while the distributed model doesn't rely on having a central repository (in the traditional sense), it's common to implement one copy of the repository, which is hosted by services such as GitHub, GitLab, or Bitbucket. This instance serves as the focal point of collaboration and synchronization.

*Screenshot of centralized and distributed version control systems repositories and collaboration.*

![](https://learn.microsoft.com/en-us/training/wwl-azure/develop-with-devops/media/3-centralized-distributed.png)

## Git terminology

In order to become proficient in working with Git, it's important to become familiar with its terminology. Some of the concepts are unique to Git, distinguishing it from other DVCS. The most fundamental Git terms include:

**Working tree**: a directory structure that contains all of the project's files.

**Repository (commonly referred to as repo)**: the directory located at the top level of a working tree, hosting all of the project's files along with the version history of these files.

**Clone**: the action of creating a copy of a remote repository on a local machine to work on a project to which you have access.

**Fork**: the action of creating a GitHub-hosted copy of a remote repository to work on a project to which you don't have access. A fork is typically used if you intend to contribute to someone else's project or create your own version of such project. While you don't have write access to the original repository, you can fully manage your fork.

**Commit**: a snapshot of the changes made to the files in a repository at a specific point in time. Commits are used to record and save changes.

**Staging area**: an intermediate location (which isn't part of the repository) where changes to files in the working tree are prepared before they're committed. It allows developers to select changes they intend to commit.

**Branch**: a named series of linked commits. In simple terms, a branch represents a distinct version of a project. This enables working on different parts of a project at the same time without affecting its main version. The most recent commit within a branch is called the head. The default branch generated automatically when you initialize a repository is called main or master.

**Merge**: the process of combining changes from one branch (or commit) into another. This integrates changes from one branch into another.

**Object**: one of four types of entities available in a repo. These entities include blobs representing individual files, a tree representing a working tree, a commit representing a specific version of the working tree, and a *tag, which is a label assigned to an individual commit.

**Hash**: an automatically generated, unique, fixed-length identifier that represents the contents of an object. Whenever that object changes, its hash changes as well. This allows Git to determine which content within a repo has been updated.

**Remote**: a reference to another repository (other than the local one), typically pointing to the service-hosted instance of the repo. This serves as the default for push and pull operations.

**Pull**: the action that fetches changes from a remote repository and merges them into the current branch.

**Push**: the action that sends local commits to a remote repository, updating it with the changes made locally.

**Fetch**: the action that retrieves changes from a remote repository without automatically merging them. This allows for their review before applying a merge.

**Pull request**: a feature in Git-based hosting platforms (such as GitHub) that allows developers to propose changes and request for them to be merged into a target branch.

Git also has an extensive set of commands, which provide the ability to fully implement and manage version control through command shell such as Linux Bash or Windows Command Prompt. Alternatively, you can manage Git through desktop applications such as GitHub Desktop. Git-based hosting platforms provide a web interface that facilitates interaction with service-side repositories.

## Git vs. GitHub

As described earlier, Git is a multi-platform, open-source DVCS that facilitates collaboration by using local repositories, which can be synchronized with remote repositories. GitHub is a cloud-based service that provides a hosting platform for Git repositories. It extends the range of Git capabilities by including support for:

**Remote repositories**: facilitating interaction among distributed teams.

**Collaboration tools**: delivering such features as issues, discussions, pull requests, notifications, labels, actions, forks, wikis, and projects.

**Web-based interface**: minimizing the need to use Git commands

**Branch protection**: enforcing conditions that must be satisfied before a merge can take place (such as, for example, completed pull request reviews).


# 3.4 Explore GitHub flow

GitHub flow illustrates how GitHub can add value to the traditional Git-based collaborative software development. Its purpose is to streamline updates to GitHub-hosted projects by providing a prescriptive guidance on the process of applying changes to the project's repository. The organization in our sample scenario would likely benefit from incorporating GitHub Flow into their DevOps practices, especially considering their lack of experience in using Git-based repositories. In this unit, review the sequence of steps that represent the most common use case of GitHub flow.

## Following GitHub flow

GitHub flow consists of the following steps:

![](https://learn.microsoft.com/en-us/training/wwl-azure/develop-with-devops/media/4-git-workflow.png)

1. **Creating a repository**. To follow GitHub flow, you'll need a GitHub account and a repository. By default, a new repository includes the default branch, typically named *main*.

2. **Creating a branch**. Creating another branch allows you to develop and save your changes without affecting the default branch. In addition, it allows others to collaborate on your changes by reviewing them before they're merged into the main branch. You could create a branch directly in GitHub or clone the repository to your local computer and create a branch there.

3. **Making changes to the branch**. Apply changes to the newly created branch by invoking the commit and (if working locally) push actions. You can edit files directly in the GitHub hosted repository by using the GitHub web interface. For every commit, provide a short message describing the changes you applied. Repeat these steps until you consider your changes complete and you're ready to ask others to review them.

4. **Creating a pull request**. Request for feedback by creating a pull request (commonly abbreviated as *PR*) following the last commit to the branch you created. Provide a summary of changes included in the branch and explain the improvement they intend to bring. Use the *@* mention notation if you want to request a review from specific individuals or teams.

![](https://learn.microsoft.com/en-us/training/wwl-azure/develop-with-devops/media/3-pull-requests.png)

5. **Reviewing the pull request**. This is where others step in, review your pull request, and submit their feedback, including comments, questions, and suggestions.

6. **Addressing review comments**. Once the reviews are completed, you adjust your changes to take them into account and await the pull request approval.

7. **Merging the pull request**. Approving the pull request allows you to merge the content of the branch you created with the default (main) branch. GitHub by default retains the comments and commits in the pull request, which allows you and others to revisit them at any point. When implementing branch protection, its restrictions might affect the ability to merge, so ensure that they're satisfied first.

8. **Deleting the branch**. Once the merge is complete, you can delete the branch you created. This helps minimize the size of the repository and prevents an accidental use of stale branches.


# 3.5 Explore Continuous Integration

Continuous integration (CI) is one of the most fundamental DevOps elements. It promotes collaboration, contributes to early detection of code quality issues, and benefits the streamlined development process. It also serves as the foundation of continuous delivery and deployment. By employing the CI practices, the organization described in our sample scenario will be able to eliminate the manual effort involved in building and testing its applications, effectively expediting their delivery to their users. To help you gain full appreciation of CI benefits, we'll describe them in this unit.

## What is Continuous Integration?

Continuous integration is the process of automatically building and testing updated versions of software following individual updates to the software repository. In general, the integration pattern involves developers submitting their changes in separate branches via pull requests. The changes are subject to a collective review and, assuming its successful outcome, are merged into the main branch. Individual commit or merge events might be used to trigger code build and testing in order to ensure that proposed or resulting changes don't have adverse effects. With continuous integration in place, the build and tests are fully automated.

![](https://learn.microsoft.com/en-us/training/wwl-azure/develop-with-devops/media/5-continuous-integration.png)

This automation is based on build and test definitions created by developers and implemented in the repository hosting platform. For example, GitHub offers for this purpose GitHub Actions workflow, while Azure DevOps relies on Azure Pipelines.

https://youtu.be/URmeTqglS58

## What are the benefits of Continuous Integration?

The primary benefits associated with continuous integration are based on the general shift-left strategy, which (as you'll find out later in this module) also influences many other DevOps practices. The basic premise is that the longer it takes to detect an issue introduced through a code change, the more expensive and effort consuming it's to fix it. With continuous integration, code build and testing take place as soon as possible. They're also implemented in an automated manner, which increases their speed and reliability. Continuous integration improves consistency, ensuring that builds and tests are conducted in a reproducible manner. That consistency, in turn, helps enforce programming standards, resulting in cleaner and easier to maintain code. Last, but not least, continuous integration is typically part of continuous delivery, streamlining entire application lifecycle management. Minimizing the overhead associated with maintaining the build, test, and deployment activities increase overall productivity of development and operation teams, reducing time-to-market for software products.



# 3.6 Explore shift-left testing


Testing in application lifecycle management is essential to maximize code quality and minimize operational risk associated with deploying and updating software. The term shift-left in this context conveys the idea of moving testing activities as early as possible in the development phase. The organization in our sample scenario should consider incorporating this approach into its DevOps strategy in order to minimize the current security and stability issues. In this unit, review different types of tests that could be implemented in this manner and then examine their implementation methods.

![](https://learn.microsoft.com/en-us/training/wwl-azure/develop-with-devops/media/6-shift-left-quality-vision.png)

## What tests should be part of shift-left testing?

Software development incorporates a wide range of test types, but those of a particular interest to us include:

**Unit tests**: These tests focus on the smallest testable parts of an application code, such as individual functions or methods. The objective is to establish whether each unit of code can successfully perform its intended operation in isolation from the rest of the codebase and external dependencies. Such tests should be fully automated, quick (complete within 30 seconds), and provide full code coverage (which basically means that all unit tests should collectively test the entire codebase). Unit testing is suitable for the shift-left approach. We recommend applying it to all code as early in the development cycle as possible, preferably at the beginning of the programming phase.

![](https://learn.microsoft.com/en-us/training/wwl-azure/develop-with-devops/media/6-test-vision.png)

**Smoke tests**: These tests are meant to assess the core functionality of an application in a test environment. While they test the actual application (rather than its individual, isolated components, as unit tests do), their purpose is to determine if the application build or deployment is sufficiently stable to warrant more in-depth testing. However, they don't verify interoperability between apps. As with unit tests, they should be fully automated and relatively quick (user interaction can be simulated by using browser automation tools and user interface automation frameworks). The term smoke test is meant to convey the idea of smoke indicating a major issue (fire) that should be addressed as soon as possible. Smoke testing should also be implemented early in the development cycle, preferably as soon as a version of the software providing its core functionality is available. This applies to both the application build and deployment phases.

**Integration tests**: These tests validate interaction between different application components. Unlike unit tests, they can take a considerable amount of time to complete. The extended duration of these tests is commonly used as an argument for running them early in the software development lifecycle. In general, you should consider integration tests in scenarios for which unit or smoke tests aren't suitable. However, the recommendation is to schedule them to execute in regular intervals. This approach offers a reasonable compromise between a potential delay in detecting integration issues and an extra wait time required to complete them.

**Acceptance tests**: These tests determine whether a software product meets the business requirements and is ready for a delivery to its consumers. Acceptance testing isn't suitable for the shift-left strategy, but it might be possible to incorporate some of its elements early in the software development lifecycle. For example, acceptance criteria and user stories, which are essential components of acceptance testing, should be introduced early in the development process. This facilitates collaboration between development teams, product owners, and project stakeholders. In addition, software consumers and project stakeholders should be engaged in the earlier testing phases in order to share their feedback. This might involve using such methods as alpha or beta testing, usability testing, or early releases, ahead of the formal acceptance testing.


# 3.7 Explore shift-left security

The *shift-left* approach is recommended not only in regard to testing. The same idea extends into the realm of security. The principles of DevSecOps are meant to convey the significance of incorporating security into every phase of DevOps (starting with planning and development), in the manner sometimes referred to as *Continuous Security*. The organization described in our sample scenario is well-aware of the implications of ignoring these principles. In this unit, examine the meaning of the *shift-left* approach to security and the recommended ways to implement it.

![](https://learn.microsoft.com/en-us/training/wwl-azure/develop-with-devops/media/7-shift-security-left.png)

## What is shift-left security?

In the context of security, shift-left translates into introducing security activities as early in the software lifecycle processes as possible. This starts with incorporating security in software design by using threat modeling in order to identify potential future threats, assess risks, and define mitigation strategies. The process continues throughout software development by implementing a range of security-related activities such as code reviews and automated security testing. Code reviews should include security-focused assessments, targeting security flaws, adherence to coding standards, and potential vulnerabilities. Automated security testing involves such tasks as static application security testing (SAST), dynamic application security testing (DAST), and software composition analysis (SCA), which are integrated into continuous integration/continuous deployment (CI/CD) pipelines.

Continuous monitoring, which is part of continuous security, is another element suitable for the shift-left approach. Its implementation involves applying logging, monitoring, and incident response mechanisms from the beginning of development.


# 3.8 Implement flow of work with GitHub

## Scenario

Remember this module's scenario in which you're working for a software development company in the retail industry that is planning to migrate an online store from an old app to a new app called eShopOnWeb. Since you have decided to use Git and GitHub to facilitate application lifecycle management, this lab gives you the opportunity to start by forking an existing repo, configuring it, create an issue, creating a branch, updating files in the branch, creating and merging a pull request, closing the issue, and validate the changes.

## Objectives

In this lab, you will:

* Implement and manage repos with GitHub

## Prerequisites

* Complete the first lab in this series, Lab 01 - Agile Planning and Management using GitHub.

## Requirements

* Use the same GitHub account you created for the purpose of the first lab.
* This lab requires **Microsoft Edge** or an Azure DevOps-supported browser.
* **GitHub account:** If you don't already have a GitHub account that you can use for this lab, create one by following the instructions available in the article Creating an account on GitHub.

## Exercises

During this lab, you'll complete the following exercises:

* Exercise 1: Implement and manage repos with GitHub

https://microsoftlearning.github.io/AZ-2008_DevOps_Foundations_Core_Principles_Practices/Instructions/Labs/02-implement-manage-repositories-using-github.html



# 3.9 Module assessment

Choose the best response for each question.

*AI-generated content The question and answer choices in this module assessment were created with AI.*

**Provide feedback**

## 1.
**How does collaboration differ in centralized versus distributed version control systems?**

- ✅ **Distributed systems allow changes to be committed locally before synchronization.**
- Centralized systems enable disconnected authoring of code.
- Distributed systems prevent changes to checked-out files by others.

## 2.
**Which feature of GitHub allows developers to propose changes and request their review before merging?**

- Commit
- Clone
- ✅ **Pull requests**

## 3.
**What is a unique characteristic of centralized version control systems compared to distributed ones?**

- Each developer has a fully functional local copy of the repository.
- ✅ **Requires network connectivity for updates and history retrieval.**
- Branches are created independently in local copies.

## 4.
**In a distributed version control system, what is a primary benefit of having local repositories for each team member?**

- Ensures all changes are immediately visible to all team members.
- ✅ **Ability to work offline without network connectivity.**
- Simplifies the branching and merging process.

## 5.
**What is the role of the 'main' branch in GitHub workflow?**

- ✅ **The 'main' branch serves as the primary branch where final, reviewed code is merged and maintained.**
- It is a temporary branch used for feature development and testing.
- The 'main' branch is used to store automated test results and logs.

## 6.
**In GitHub, what does it mean to 'merge a branch'?**

- Creating a duplicate of a branch for backup purposes.
- Deleting a branch after development is complete.
- ✅ **Combining changes from one branch into another, typically integrating them into the main branch.**

## 7.
**What is the primary role of the 'main' branch in a Git repository?**

- To automatically merge all incoming changes from feature branches.
- ✅ **To serve as the default branch containing the stable codebase for production releases.**
- To store experimental code that is not yet ready for production.

## 8.
**During a code review in GitHub, a developer notices that a proposed change breaks the build. What GitHub feature should they use to propose modifications before merging the branch?**

- Push
- ✅ **Pull request**
- Fork

## 9.
**Which concept ensures multiple developers can work on the same codebase simultaneously without conflict in Git?**

- Commit
- Staging area
- ✅ **Branching**

---

## Answer Explanations:

**1.** In distributed systems, developers can commit changes to their local repository and synchronize later, unlike centralized systems that require immediate network connectivity.

**2.** Pull requests are GitHub's mechanism for proposing changes and requesting code reviews before merging.

**3.** Centralized systems require network connectivity for most operations, while distributed systems can work offline.

**4.** Local repositories in distributed systems allow developers to work without network connectivity.

**5.** The main branch serves as the stable, production-ready branch where reviewed code is integrated.

**6.** Merging combines changes from one branch into another, typically integrating feature branches into main.

**7.** The main branch contains the stable codebase that's ready for production releases.

**8.** Pull requests allow developers to propose and discuss changes before merging, including suggesting modifications.

**9.** Branching allows multiple developers to work on different features simultaneously without conflicts.



# 3.10 Summary

In this module, you have learned about the importance of source control and version control in DevOps. These practices are crucial for achieving continuous integration and infrastructure as code. Transitioning to a distributed version control model like Git is recommended, especially if using GitHub for software lifecycle management. Git allows for tracking changes, creating branches, merging branches, collaborating with multiple developers, and automating processes like continuous integration and deployment.

The main takeaways from this module are that version control systems can be categorized as centralized or distributed, with Git being the most popular choice for DevOps environments. GitHub is a cloud-based service that hosts Git repositories and provides collaboration tools. The GitHub flow process helps streamline updates to GitHub-hosted projects. Continuous integration is a key component of DevOps that promotes collaboration and early detection of code quality issues. Shift-left testing involves moving testing activities as early as possible in the development phase to improve code quality and minimize operational risk. It includes unit tests, smoke tests, integration tests, and acceptance tests. Shift-left security is also important, integrating security activities early in the software lifecycle and continuing throughout development.


# 4 Deliver with DevOps

Build and run continuous integration and continuous delivery workflows using GitHub Actions. Your workflows will have accelerated release cycles, increased resiliency, improved collaboration and reusability, and infrastructure as code.

#### Learning objectives
Upon completion of this module, you'll be able to:
- Define the concept of continuous delivery.
- Describe the concept and implementation methods of IaC.
- Review the progressive exposure techniques and deployment practices.
- Explore DevOps shift-right testing scenarios.
- Describe how to implement continuous delivery with GitHub Actions.


# 4.1 Introduction

Continuous integration and continuous delivery (CI/CD) are important concepts in DevOps that focus on building, testing, and automating the delivery of software artifacts.

Imagine that you work for a software development company in the retail industry that is preparing to release a new version of their online store application. The company wants to ensure that the release process is efficient, reliable, and minimizes the risk of errors. Therefore, you decide to follow a DevOps approach and use GitHub for software lifecycle management. By implementing CI/CD, the company can automate the build, test, and deployment processes, reducing manual effort and improving the overall quality of the software. It allows the company to deliver new features and bug fixes to their users quickly and consistently.

In this module, learn about continuous delivery (CD) and its benefits such as accelerated release cycles, increased resiliency, improved collaboration, and reusability, continuous integration (CI), and its relationship with CD, infrastructure as Code (IaC) and its principles, applying CI/CD practices to IaC deployment, and progressive exposure techniques in continuous delivery. Additionally, you'll be introduced to GitHub Actions and its components, including how to create a GitHub Actions workflow, to support the implementation of CI/CD.

By the end of this module, you'll be able to apply CI/CD practices to your software development workflows and improve the efficiency and reliability of your software releases.


# 4.2 Explore continuous delivery

Continuous integration (CI) and continuous delivery (CD) are closely related DevOps concepts, representing two distinct stages of the software delivery process. As you know from the previous module, the purpose of CI is to build and test software artifacts. CD automates the process of delivering these artifacts to their intended recipients. By implementing CD, organizations such as the one described in the sample scenario, are able to eliminate the manual effort involved in application deployment. In this unit, explore the characteristics and benefits of CD.

## What is continuous delivery?

Continuous delivery comprises the practices, which automate generation of software releases, ensure they are in a deployable state, and make them available to their consumers. Its focus is on minimizing the *time to deploy* and *time to mitigate (TTM)*, also known as *time to remediate (TTR)*. The latter refers to scenarios where a newly released version of the application reaches the production environment and needs to be rolled back.

Continuous delivery tends to be an iterative process, where the same artifact representing the latest software release transitions through several environments, which are dedicated, for example, to user acceptance testing, staging, and production. This provides ample opportunities to validate its functionality and stability.

It's worth noting that DevOps nomenclature includes two closely related terms, which have similar names and the same acronym – continuous delivery and continuous deployment. Both deal with automating and streamlining the software delivery process. The primary distinction between them is that the latter strives to implement full automation, including the production environment, while in case of the former, that final delivery requires a manual approval.

Akin to CI, automation is based on release definitions created by developers and implemented in the repository hosting platform. For example, GitHub offers for this purpose GitHub Actions workflow, while Azure DevOps relies on Azure Pipelines.

## What are the benefits of continuous delivery?

Benefits associated with continuous delivery are direct results of its automation and the shift-left approach. The most relevant ones include:

* **Accelerated release cycles**: Organizations are able to increase the delivery speed of new features, enhancements, and bug fixes, which translates into reduced time-to-market, ultimately benefiting customers.

* **Increased resiliency**: Automated testing allows for detecting issues early in the delivery process. Automated deployment ensures consistency across environments and minimizes the potential impact of human errors. Automation also tends to considerably simplify the rollback process in case there's a need to revert to a previous software version. Incremental rollout (which we'll cover later in this module) facilitate discovery of any potential issues before they might have a wider scale impact. Rapid feedback loops reduce response time if an issue is discovered.

* **Improved collaboration**: CD promotes interaction across development, operations, and security teams by integrating with CI, resulting in one cohesive process encompassing build, testing, and delivery.

* **Efficient resource utilization**: Automation tends to minimize time spent on manual, repetitive, and time-consuming tasks, resulting in optimized usage of human resources.


# 4.3 Explore Infrastructure as Code

Infrastructure as Code is an integral component of modern software development and operations practices. It involves the use of programming methods to provision and manage infrastructure services. IaC is beneficial in cloud-based environments, such as the one described in the sample scenario. However, any organization that relies on computing assets for its revenue can take advantage of its capabilities. In this unit, you'll learn about the main principles of IaC and the most common techniques of implementing these principles.

## What are the main principles of IaC?

While individual implementations of IaC may differ significantly, they all tend to follow a set of common principles, including:

**Version control**: IaC defines infrastructure components, including compute, storage, and network resources by using code. Such code typically resides in a VCS, which facilitates tracking changes to infrastructure in the same manner as tracking software versions.

**Declarative syntax**: IaC relies on declarative syntax in order to describe the desired state of the infrastructure. This contrasts with a more traditional imperative syntax, which involves writing code that defines a step-by-step procedure leading to that state. The declarative approach tends to be more efficient for many reasons. For one, it relies on the intelligence of the platform hosting the infrastructure components, minimizing the possibility of programming errors or inefficiencies. In addition, it ensures idempotence.

**Idempotence**: This term designates the characteristic of an action where the outcome is always the same, regardless of the number of times the action is performed. Since the declarative syntax describes the end state only, using it guarantees that each code execution will always yield the same result. This ensures the consistency of the target environment and precludes the possibility of unintended side effects of intermediary changes.

**Automation**: The use of code facilitates automated provisioning and configuration, enhancing efficiency, consistency, and scalability. This also eliminates the potential impact of manual errors.

**CI/CD integration**: IaC can be (and frequently is) integrated with CI/CD, yielding a comprehensive software delivery strategy by combining infrastructure provisioning, with application build, test, and deployment into one continuous, fully automated sequence.

**Reusability**: IaC promotes the use of reusable code modules, in accordance with the best programming practices. This facilitates development of software libraries consisting of standardized infrastructure building blocks that can be shared across projects. As a result, organizations benefit from increased consistency, simplified maintenance, and minimized duplication of efforts.

## How to implement IaC?

Implementing IaC starts with identifying infrastructure requirements, including compute, storage, and networking components. Details depend largely on the platform hosting that infrastructure and could differ significantly depending, for example, on the use of public or private cloud environments.

![](https://learn.microsoft.com/en-us/training/wwl-azure/deliver-with-devops/media/3-infrastructure-as-code.png)

The choice of the platform will also have an impact on the choice of the IaC technology and tools. For example, each public cloud provider offers its own set of IaC capabilities. In the case of Microsoft Azure, these capabilities are based on Azure Resource Manager (ARM) and Bicep templates. There are also solutions that offer multicloud support, such as Terraform. The choice of tool determines the type of files and the corresponding directory structure of your projects. This should allow you to set up repositories in the version control system of your choice. VCS repos facilitate tracking infrastructure changes, intra and cross-team collaboration, automation for deployments and rollbacks, as well as integration with CI/CD workflows.

With the repository in place, you should start building an IaC code library, consisting of modules representing building blocks of your future infrastructure deployments. Such blocks could, for example, represent individual servers, networks, or data stores, which you can mix and match in an arbitrary manner to construct multi-resource solutions.

The next step would typically involve integrating your IaC environment with CI/CD workflows. Commonly, this would involve using the same set of repositories, facilitating combining deployment of infrastructure with building, testing, and delivery of the software hosted on that infrastructure. However, the integration should extend to applying CI/CD practices to your IaC deployments. In particular, you should ensure that, as with CI/CD, you utilize development and staging environments, automate testing, implement monitoring and feedback loops, and properly secure your infrastructure code and the IaC processes.


# 4.4 Explore progressive exposure techniques

As described in the first unit of this module, continuous delivery offers numerous benefits, including accelerated release cycles, improved collaboration, efficient resource utilization, and increased resiliency. The last of these ties, to some extent, to the ability to deliver new software versions to their intended recipients in a gradual manner. This helps to limit the scope of a negative impact if there is undetected code quality issues and gather customer feedback that might influence the decision to continue with the delivery. The organization in the sample scenario would be able to utilize this capability in order to mitigate its current operational challenges. In this unit, you'll learn about different progressive exposure techniques that contribute to increased resiliency.

## What are progressive exposure techniques?

CD practices feature several delivery patterns for progressive exposure. Their purpose is to minimize potential damage caused by programming errors that CI-based code analysis, reviews, and automated testing failed to uncover (this objective is also commonly referred to as *controlling the blast radius*). The most commonly used techniques include:

* **Deployment rings**: A ring designates a deployment targeting a particular group of users, which is later monitored to determine their experiences. The first deployment ring is sometimes called *canary*, referencing the term *canary in the coal mine* borrowed from the old mining practice of using canaries to warn about elevated levels of carbon monoxide. CD automates transitioning from one ring to the next, although the transition might depend on a manual approval. Such practices might be required in order to comply with regulatory requirements or internal governance rules.

![](https://learn.microsoft.com/en-us/training/wwl-azure/deliver-with-devops/media/4-deployment-rings.png)

* **Blue/green deployments**: The two colors designate two different versions of the same application, with *blue* representing the current (known as stable) version and *green* representing an updated one (being released). The intention is to have both versions running side-by-side and using load balancing to gradually increase the volume of incoming requests from the *blue* to *green* version. If there's an issue with *green*, the incoming requests can be easily rerouted back to *blue*.

![](https://learn.microsoft.com/en-us/training/wwl-azure/deliver-with-devops/media/4-blue-green.png)

* **Feature flags** (also referred to as **feature toggles**): A feature flag designates a programming method, which involves placing throughout code conditional statements, which selectively disable or enable certain code segments. The statements are activated by setting a value of a flag, which is typically placed in an external configuration store. Effectively, it's possible to enable or disable new features on an as-needed basis without having to modify or deploy the code.

![](https://learn.microsoft.com/en-us/training/wwl-azure/deliver-with-devops/media/4-feature-flags.png)

* **Dark launches**: Dark launches represent a deployment strategy that involves deploying new features in an inactive state and enabling them in a controlled manner after deployment. This approach typically relies on the use of feature flags.

![](https://learn.microsoft.com/en-us/training/wwl-azure/deliver-with-devops/media/4-dark-launches.png)


# 4.5 Explore continuous delivery with GitHub Actions

GitHub Actions provide the mechanism for implementing software delivery workflows by using the capabilities of the GitHub platform. This would be the most optimal CI/CD approach for the organization in our sample scenario, considering its plans to use GitHub for its DevOps journey. In this unit, you'll learn about using GitHub Actions to build and run CI/CD workflows.

## What are GitHub Actions?

https://youtu.be/cP0I9w2coGU

In the context of GitHub, the term actions actually have a dual meaning. The first one (capitalized Actions) represents the GitHub service, which provided the ability to implement CI/CD workflows. The second one (lower case actions) designates reusable units that can be included in workflows to deliver a specific functionality, such as running scripts and executables, building and uploading artifacts, or setting up access to an Azure subscription.

![](https://learn.microsoft.com/en-us/training/wwl-azure/deliver-with-devops/media/5-continuous-delivery-github.png)

## What are the main components of GitHub Actions?

The key components of GitHub Actions include:

**workflow**: a sequence of steps stored in a YAML-formatted file. Workflows execute the steps once they're triggered either manually or (more frequently) automatically by repository-related activities, such as pushes or branch merges.

**job**: a top element of a workflow. Jobs within a workflow can run in parallel or sequentially.

**step**: a top element within a job. Each step is a task or action that performs a specific activity, such as running a script or building an artifact.

**action**: a prebuild or custom-developed activity (as mentioned earlier). GitHub provides a marketplace where you can find a wide range of prebuilt actions.

**variable**: a named value that allows you to store and reuse data across steps in a workflow. You can create your own custom variables or use any of the predefined, default environment variables automatically set within each workflow.

**secret**: an encrypted variable that can be used to store sensitive data.

## How to create a GitHub Actions workflow?

To create a GitHub Actions workflow, use the following steps:

1. **Create a repository**. To implement GitHub Actions workflow, you'll need a GitHub account and a repository. By default, a new repository includes the default branch, typically named main.

2. **Create a .github/workflows directory**. GitHub Actions workflows should reside in the .github/workflows directory in the repository root.

3. **Create a YAML file**. GitHub Actions workflow has the YAML format. Its name is arbitrary, but the extension is expected to be set to .yml.

4. **Define the workflow in the YAML file and save the changes**. The YAML file needs to include the workflow definition.

5. **Commit the saved file to the repository**. To finalize the workflow changes, you need to execute commit, as with any file that is part of the repository. If you decide to author a workflow on your local computer (rather than by using the GitHub web interface), you would clone the repository after you create it, apply and commit changes locally, and then push them to GitHub.

Here's a simple example of a GitHub Actions workflow that displays a message Hello from GitHub Actions! once executed.

```yml
name: Simple GitHub Actions workflow

on: [push]

jobs:
  say_hello:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v2

    - name: Run Build Script
      run: |
        echo "Hello, GitHub Actions!"
```

The first line of the workflow defines its name, which is displayed on the repository's Actions tab in the GitHub web interface. The on: [push] line designates the event, which triggers the workflow run (in this case, a push to any branch in the workflow's repository).

The workflow consists of a single job named say_hello, as indicated by the content following the jobs: line. The next line (runs-on: ubuntu-latest) determines the type of operating system that should be used to run the job. The choice is dependent on the tasks the job contains and, in this case, the job would run as well on any Windows-based operating system.

The job consists of two steps, as indicated by the content following the steps: line. The step syntax supports an optional name attribute, which might help understand the step's purpose when reviewing the workflow runs. The remainder of the syntax is dependent on the type of action that a given step is meant to carry out. In this example, the first step is checking out the current repository (which downloads the content of the repository to the system where the job is running), while the second one runs the echo command, which displays a friendly message.

To integrate the CI/CD functionality into GitHub Actions workflows, you would add a series of steps (in one or more jobs) that perform automated build, test, and deployment actions. Once the workflow execution is triggered, you could track its progress by navigating to the "Actions" tab in your GitHub repository.

> **Note**
>
> You will have a chance to work with more meaningful examples of GitHub Actions workflows that illustrate CI/CD integration in the lab of this module.



# 4.6 Implement CI/CD with GitHub Actions and IaC with Bicep

## Scenario

Remember this module's scenario in which you work for a software development company in the retail industry that wants to ensure that the release process of a new version of their online store application is efficient and reliable while minimizing the risk of errors. Since you have decided to use GitHub to facilitate application lifecycle management, this lab gives you the opportunity to fork and review the GitHub repo containing the source code of a web app, a GitHub Actions workflow, and a Bicep template. Additionally, you'll be able to configure the target environment and validate the Infrastructure as Code (IaC) and CI/CD functionality.

Please note that in the previous lab, you configured GitHub Pages, which means you have already implemented continuous deployment, potentially without even realizing it. GitHub Pages uses GitHub Actions in the background to perform automated deployments following any commits to the main branch. You can verify this by navigating to the Actions tab on the main page of the forked repo, Spoon-Knife. Now, you will enhance this functionality. Specifically, you will use a custom-developed GitHub Actions workflow with a Bicep template to provision a couple of Azure App Service web apps in different Azure regions and deploy a custom .NET web app into both of them.

## Objectives

In this lab, you will:

* Prepare the Azure subscription for the lab
* Implement Infrastructure as Code (IaC) and CI/CD with GitHub Actions and a Bicep template

## Prerequisites

* Use the same GitHub account you created for the purpose of the first lab.
* Complete the first lab in this series, Lab 01 - Agile Planning and Management using GitHub.
* Complete the second lab in this series, Lab 02 - Implement Flow of Work with GitHub.

## Requirements

* This lab requires **Microsoft Edge** or an Azure DevOps-supported browser.
* **GitHub account:** If you don't already have a GitHub account that you can use for this lab, create one by following the instructions available in the article Creating an account on GitHub.
* An **Azure subscription** to which you have at least the **Contributor-level access**. If you don't have an Azure subscription, you can sign up for a free trial.

## Exercises

During this lab, you'll complete the following exercises:

* Exercise 0: Prepare the Azure subscription for the lab
* Exercise 1: Implement Infrastructure as Code (IaC) and CI/CD with GitHub Actions and a Bicep template

https://microsoftlearning.github.io/AZ-2008_DevOps_Foundations_Core_Principles_Practices/Instructions/Labs/03-implement-ci-cd-with-github-actions-and-iac-with-bicep.html


# 4.7 Summary

In this module, you have learned about two important concepts in DevOps: continuous integration (CI) and continuous delivery (CD). CI focuses on building and testing software artifacts, while CD automates the process of delivering these artifacts to users. Continuous delivery involves automating the generation of software releases, ensuring they're deployable, and making them available to consumers. It aims to minimize the time to deploy and mitigate issues. Continuous delivery is an iterative process that involves transitioning the latest software release through different environments for testing and validation.

The main takeaways from this module are that continuous delivery offers several benefits, including accelerated release cycles, increased resiliency, improved collaboration, and efficient resource utilization. It allows for faster deployment of software releases and enables organizations to gather customer feedback gradually. Progressive exposure techniques, such as deployment rings, blue/green deployments, feature flags, and dark launches, contribute to increased resiliency in continuous delivery practices. Additionally, GitHub Actions are a powerful tool for implementing software delivery workflows on the GitHub platform, allowing you to build and run CI/CD workflows using various components.



